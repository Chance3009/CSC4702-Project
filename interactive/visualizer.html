<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robotics 3D Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            user-select: none;
        }

        h2 {
            margin-bottom: 5px;
            color: #2c3e50;
        }

        p {
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        /* Main Layout */
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        /* LEFT: Control Panel */
        .controls {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 320px;
            height: fit-content;
        }

        .control-group {
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #34495e;
            font-size: 16px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        /* Matrix Display */
        .matrix-box {
            font-family: 'Courier New', monospace;
            background: #222;
            color: #0f0;
            padding: 15px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.6;
        }

        .highlight-pos {
            color: #ffeb3b;
            font-weight: bold;
        }

        .highlight-rot {
            color: #00e5ff;
        }

        /* RIGHT: 3D Viewport */
        .viewport {
            width: 600px;
            height: 500px;
            background: radial-gradient(circle, #ffffff 0%, #e0e0e0 100%);
            border: 2px solid #bdc3c7;
            border-radius: 12px;
            perspective: 1000px;
            overflow: hidden;
            cursor: grab;
            position: relative;
        }

        .viewport:active {
            cursor: grabbing;
        }

        /* The 3D World Wrapper (Rotated by Mouse) */
        .world {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            /* Initial Camera View */
            transform: translateZ(-100px) rotateX(-20deg) rotateY(30deg);
            transition: transform 0.1s ease-out;
            /* Smooth drag */
        }

        /* 1. The Fixed World Reference Frame (Does NOT move) */
        .fixed-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-style: preserve-3d;
        }

        .world-grid {
            position: absolute;
            width: 800px;
            height: 800px;
            left: -400px;
            top: -400px;
            background-image: linear-gradient(#ccc 1px, transparent 1px), linear-gradient(90deg, #ccc 1px, transparent 1px);
            background-size: 50px 50px;
            transform: rotateX(90deg);
            opacity: 0.5;
        }

        .world-axis {
            position: absolute;
            width: 4px;
            border-radius: 2px;
        }

        .w-x {
            height: 300px;
            background: rgba(255, 0, 0, 0.6);
            transform: rotateZ(-90deg);
            transform-origin: top left;
        }

        /* Red = X (Right) */
        .w-y {
            height: 300px;
            background: rgba(0, 128, 0, 0.6);
            transform: rotateX(90deg);
            transform-origin: top left;
        }

        /* Green = Y (Forward/Up) */
        .w-z {
            height: 300px;
            background: rgba(0, 0, 255, 0.6);
        }

        /* Blue = Z (Up/Forward) */

        /* 2. The Robot Frame (Moves) */
        .robot-frame {
            width: 100px;
            height: 100px;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -50px;
            margin-left: -50px;
            transform-style: preserve-3d;
        }

        /* Cube Faces */
        .face {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 2px solid #333;
            opacity: 0.8;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .f-front {
            background: rgba(255, 99, 71, 0.8);
            transform: translateZ(50px);
        }

        .f-back {
            background: rgba(255, 99, 71, 0.8);
            transform: rotateY(180deg) translateZ(50px);
        }

        .f-right {
            background: rgba(60, 179, 113, 0.8);
            transform: rotateY(90deg) translateZ(50px);
        }

        .f-left {
            background: rgba(60, 179, 113, 0.8);
            transform: rotateY(-90deg) translateZ(50px);
        }

        .f-top {
            background: rgba(100, 149, 237, 0.8);
            transform: rotateX(90deg) translateZ(50px);
        }

        .f-bottom {
            background: rgba(100, 149, 237, 0.8);
            transform: rotateX(-90deg) translateZ(50px);
        }

        /* Local Axis Arrows (Attached to Cube) */
        .local-axis {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform-style: preserve-3d;
        }

        .l-arrow {
            position: absolute;
            transform-origin: left center;
            height: 4px;
            border-radius: 2px;
        }

        .l-x {
            width: 150px;
            background: red;
            transform: rotateZ(-90deg);
        }

        /* Red = X (Right) */
        .l-y {
            width: 150px;
            background: green;
            transform: rotateX(90deg);
        }

        /* Green = Y (Forward/Up) */
        .l-z {
            width: 150px;
            background: blue;
        }

        /* Blue = Z (Up/Forward) */

        /* Labels */
        .axis-label {
            position: absolute;
            color: black;
            font-weight: bold;
            font-size: 14px;
        }

        /* New Interactive Sections */
        .section-container {
            width: 100%;
            max-width: 1200px;
            margin-top: 30px;
        }

        .section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .section h3 {
            color: #2c3e50;
            margin-top: 0;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .transform-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .transform-result {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .pose-frame {
            position: relative;
            height: 200px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            margin: 10px 0;
        }

        .mini-viewport {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #ffffff 0%, #e0e0e0 100%);
            position: relative;
            overflow: hidden;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }

        button:hover {
            background: #2980b9;
        }

        .info-text {
            color: #555;
            font-size: 13px;
            line-height: 1.6;
            margin: 10px 0;
        }

        @media (max-width: 900px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>

    <h2>Interactive Robotics Visualizer</h2>
    <p>Topic: Homogeneous Transformation Matrices</p>

    <div class="container">

        <div class="controls">
            <div class="control-group">
                <h4>1. Translation (Position)</h4>
                <label>X (Red Axis): <span id="valPx">0</span></label>
                <input type="range" id="posX" min="-200" max="200" value="0" oninput="updateRobot()">

                <label>Y (Green Axis): <span id="valPy">0</span></label>
                <input type="range" id="posY" min="-200" max="200" value="0" oninput="updateRobot()">

                <label>Z (Blue Axis): <span id="valPz">0</span></label>
                <input type="range" id="posZ" min="-200" max="200" value="0" oninput="updateRobot()">
            </div>

            <div class="control-group">
                <h4>2. Rotation (Orientation)</h4>
                <label>Roll (X): <span id="valRX">0</span>°</label>
                <input type="range" id="rotX" min="-180" max="180" value="0" oninput="updateRobot()">

                <label>Pitch (Y): <span id="valRY">0</span>°</label>
                <input type="range" id="rotY" min="-180" max="180" value="0" oninput="updateRobot()">

                <label>Yaw (Z): <span id="valRZ">0</span>°</label>
                <input type="range" id="rotZ" min="-180" max="180" value="0" oninput="updateRobot()">
            </div>

            <div class="matrix-box">
                <div id="matrixOutput">Loading...</div>
            </div>
            <div style="margin-top:10px; font-size:11px; color:#555;">
                * Camera: Click & Drag to Rotate, Scroll to Zoom
            </div>
        </div>

        <div class="viewport" id="viewport">
            <div class="world" id="world">

                <div class="fixed-frame">
                    <div class="world-grid"></div>
                    <div class="world-axis w-x"></div>
                    <div class="world-axis w-y"></div>
                    <div class="world-axis w-z"></div>
                    <div style="position:absolute; transform: translate(10px,10px); color: #888; font-size:12px;">World
                        Origin {0}</div>
                    <div
                        style="position:absolute; transform: translate(310px, -10px) rotateZ(-90deg); color: #ff0000; font-size:12px; font-weight:bold;">
                        X</div>
                    <div
                        style="position:absolute; transform: translate(-15px, 10px) translateZ(310px); color: #008000; font-size:12px; font-weight:bold;">
                        Y</div>
                    <div
                        style="position:absolute; transform: translate(10px, -310px); color: #0000ff; font-size:12px; font-weight:bold;">
                        Z</div>
                </div>

                <div class="robot-frame" id="robot">
                    <div class="face f-front">Front</div>
                    <div class="face f-back">Back</div>
                    <div class="face f-right">Right</div>
                    <div class="face f-left">Left</div>
                    <div class="face f-top">Top</div>
                    <div class="face f-bottom">Bot</div>

                    <div class="local-axis">
                        <div class="l-arrow l-x"></div> <span class="axis-label"
                            style="transform: translate(0,-160px)">X</span>
                        <div class="l-arrow l-y"></div> <span class="axis-label"
                            style="transform: translate(0,0) translateZ(160px)">Y</span>
                        <div class="l-arrow l-z"></div> <span class="axis-label"
                            style="transform: translate(0,0) translateZ(-160px)">Z</span>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- New Interactive Sections -->
    <div class="section-container">

        <!-- Section 1: Composing Relative Poses -->
        <div class="section">
            <h3>Composing Relative Poses</h3>
            <p class="info-text">Explore how to combine two transformations: T₁ (Frame 1 relative to World) and T₂
                (Frame 2 relative to Frame 1).
                The result T₃ = T₁ × T₂ represents Frame 2 relative to World.</p>

            <div class="two-column">
                <div class="transform-controls">
                    <h4 style="margin-top:0;">Frame 1 (T₁): Base Frame</h4>
                    <label>X₁: <span id="comp1X">0</span></label>
                    <input type="range" id="compPos1X" min="-150" max="150" value="0" oninput="updateComposition()">
                    <label>Y₁: <span id="comp1Y">0</span></label>
                    <input type="range" id="compPos1Y" min="-150" max="150" value="0" oninput="updateComposition()">
                    <label>Z₁: <span id="comp1Z">0</span></label>
                    <input type="range" id="compPos1Z" min="-150" max="150" value="0" oninput="updateComposition()">
                    <label>Roll₁: <span id="comp1RX">0</span>°</label>
                    <input type="range" id="compRot1X" min="-180" max="180" value="0" oninput="updateComposition()">
                    <label>Pitch₁: <span id="comp1RY">0</span>°</label>
                    <input type="range" id="compRot1Y" min="-180" max="180" value="0" oninput="updateComposition()">
                    <label>Yaw₁: <span id="comp1RZ">0</span>°</label>
                    <input type="range" id="compRot1Z" min="-180" max="180" value="0" oninput="updateComposition()">
                </div>

                <div class="transform-controls">
                    <h4 style="margin-top:0;">Frame 2 (T₂): Relative to Frame 1</h4>
                    <label>X₂: <span id="comp2X">0</span></label>
                    <input type="range" id="compPos2X" min="-150" max="150" value="50" oninput="updateComposition()">
                    <label>Y₂: <span id="comp2Y">0</span></label>
                    <input type="range" id="compPos2Y" min="-150" max="150" value="0" oninput="updateComposition()">
                    <label>Z₂: <span id="comp2Z">0</span></label>
                    <input type="range" id="compPos2Z" min="-150" max="150" value="0" oninput="updateComposition()">
                    <label>Roll₂: <span id="comp2RX">0</span>°</label>
                    <input type="range" id="compRot2X" min="-180" max="180" value="0" oninput="updateComposition()">
                    <label>Pitch₂: <span id="comp2RY">0</span>°</label>
                    <input type="range" id="compRot2Y" min="-180" max="180" value="0" oninput="updateComposition()">
                    <label>Yaw₂: <span id="comp2RZ">0</span>°</label>
                    <input type="range" id="compRot2Z" min="-180" max="180" value="45" oninput="updateComposition()">
                </div>
            </div>

            <div style="margin-top: 20px;">
                <h4>Result: T₃ = T₁ × T₂ (Frame 2 in World Coordinates)</h4>
                <div class="transform-result" id="composedMatrix">
                    [ Computing... ]
                </div>
            </div>
        </div>

        <!-- Section 2: Homogeneous Transformation Showcase -->
        <div class="section">
            <h3>Homogeneous Transformation Matrix Operations</h3>
            <p class="info-text">Visualize different transformation operations: translation only, rotation only, and
                combined transformations.</p>

            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 20px;">
                <button onclick="setTransformMode('translation')">Translation Only</button>
                <button onclick="setTransformMode('rotation')">Rotation Only</button>
                <button onclick="setTransformMode('combined')">Combined (Default)</button>
                <button onclick="setTransformMode('identity')">Identity Matrix</button>
            </div>

            <div class="two-column">
                <div>
                    <h4 style="margin-top:0;">Current Transformation Matrix</h4>
                    <div class="transform-result" id="showcaseMatrix">
                        [ Identity Matrix ]
                    </div>
                    <p class="info-text" id="showcaseInfo">Click buttons above to see different transformation types.
                    </p>
                </div>

                <div>
                    <h4 style="margin-top:0;">Matrix Properties</h4>
                    <div class="transform-controls">
                        <div style="margin: 5px 0;"><strong>Determinant:</strong> <span id="detValue">1.000</span></div>
                        <div style="margin: 5px 0;"><strong>Rotation Part Orthogonal:</strong> <span
                                id="orthoValue">Yes</span></div>
                        <div style="margin: 5px 0;"><strong>Translation Vector:</strong> <span id="transValue">[0, 0,
                                0]</span></div>
                        <div style="margin: 5px 0;"><strong>Rotation Type:</strong> <span id="rotTypeValue">Euler
                                ZYX</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Inverse Transformation -->
        <div class="section">
            <h3>Inverse Transformation</h3>
            <p class="info-text">For a transformation T, the inverse T⁻¹ transforms points from the target frame back to
                the source frame.
                For homogeneous matrices: if T = [R | t; 0 | 1], then T⁻¹ = [Rᵀ | -Rᵀt; 0 | 1]</p>

            <div class="two-column">
                <div>
                    <h4 style="margin-top:0;">Original Transformation T</h4>
                    <div class="transform-result" id="invOriginalMatrix">
                        [ Use main controls above ]
                    </div>
                </div>

                <div>
                    <h4 style="margin-top:0;">Inverse Transformation T⁻¹</h4>
                    <div class="transform-result" id="invInverseMatrix">
                        [ Computing... ]
                    </div>
                    <button onclick="updateInverse()" style="margin-top: 10px;">Update Inverse</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <p class="info-text"><strong>Verification:</strong> T × T⁻¹ should equal the identity matrix.</p>
                <div class="transform-result" id="invVerification">
                    [ Click "Update Inverse" to verify ]
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- ROBOT KINEMATICS LOGIC ---
        function updateRobot() {
            // Get inputs
            let px = parseInt(document.getElementById('posX').value);
            let py = parseInt(document.getElementById('posY').value);
            let pz = parseInt(document.getElementById('posZ').value);
            let rx = parseInt(document.getElementById('rotX').value);
            let ry = parseInt(document.getElementById('rotY').value);
            let rz = parseInt(document.getElementById('rotZ').value);

            // Update Labels
            document.getElementById('valPx').innerText = px;
            document.getElementById('valPy').innerText = py;
            document.getElementById('valPz').innerText = pz;
            document.getElementById('valRX').innerText = rx;
            document.getElementById('valRY').innerText = ry;
            document.getElementById('valRZ').innerText = rz;

            // Apply Transform to Robot Div
            // CSS coordinate system: X=Right, Y=Down, Z=Out (toward viewer)
            // Mapping: px->X (right), py->-Y (up in CSS), pz->Z (toward viewer)
            let robot = document.getElementById('robot');
            robot.style.transform = `translate3d(${px}px, ${-py}px, ${pz}px) rotateX(${-rx}deg) rotateY(${-ry}deg) rotateZ(${rz}deg)`;

            // Calculate Matrix (Math)
            let radX = rx * (Math.PI / 180);
            let radY = ry * (Math.PI / 180);
            let radZ = rz * (Math.PI / 180);
            let cX = Math.cos(radX), sX = Math.sin(radX);
            let cY = Math.cos(radY), sY = Math.sin(radY);
            let cZ = Math.cos(radZ), sZ = Math.sin(radZ);

            // Standard Rotation Matrix Rz * Ry * Rx
            let r11 = cZ * cY, r12 = cZ * sY * sX - sZ * cX, r13 = cZ * sY * cX + sZ * sX;
            let r21 = sZ * cY, r22 = sZ * sY * sX + cZ * cX, r23 = sZ * sY * cX - cZ * sX;
            let r31 = -sY, r32 = cY * sX, r33 = cY * cX;

            // Render Matrix HTML (4x4 Homogeneous Transformation Matrix)
            let html = `
            [ <span class="highlight-rot">${r11.toFixed(3)}</span>, <span class="highlight-rot">${r12.toFixed(3)}</span>, <span class="highlight-rot">${r13.toFixed(3)}</span>, <span class="highlight-pos">${px.toFixed(1)}</span> ]<br>
            [ <span class="highlight-rot">${r21.toFixed(3)}</span>, <span class="highlight-rot">${r22.toFixed(3)}</span>, <span class="highlight-rot">${r23.toFixed(3)}</span>, <span class="highlight-pos">${py.toFixed(1)}</span> ]<br>
            [ <span class="highlight-rot">${r31.toFixed(3)}</span>, <span class="highlight-rot">${r32.toFixed(3)}</span>, <span class="highlight-rot">${r33.toFixed(3)}</span>, <span class="highlight-pos">${pz.toFixed(1)}</span> ]<br>
            [ 0.000, 0.000, 0.000, 1.000 ]`;

            document.getElementById('matrixOutput').innerHTML = html;
        }

        // --- CAMERA CONTROLS LOGIC ---
        let viewport = document.getElementById('viewport');
        let world = document.getElementById('world');

        let camera = { pitch: -20, yaw: 30, zoom: -100 }; // Initial View
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        viewport.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('mouseup', () => isDragging = false);

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            // Calculate delta
            let dx = e.clientX - lastMouse.x;
            let dy = e.clientY - lastMouse.y;
            lastMouse = { x: e.clientX, y: e.clientY };

            // Update angles (Sensitivity 0.5)
            camera.yaw += dx * 0.5;
            camera.pitch -= dy * 0.5;

            updateCamera();
        });

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Zoom limits
            let newZoom = camera.zoom - e.deltaY * 0.5;
            if (newZoom < 500 && newZoom > -1000) {
                camera.zoom = newZoom;
                updateCamera();
            }
        });

        function updateCamera() {
            world.style.transform = `translateZ(${camera.zoom}px) rotateX(${camera.pitch}deg) rotateY(${camera.yaw}deg)`;
        }

        // --- COMPOSE RELATIVE POSES ---
        function updateComposition() {
            // Get Frame 1 values
            let p1x = parseInt(document.getElementById('compPos1X').value);
            let p1y = parseInt(document.getElementById('compPos1Y').value);
            let p1z = parseInt(document.getElementById('compPos1Z').value);
            let r1x = parseInt(document.getElementById('compRot1X').value);
            let r1y = parseInt(document.getElementById('compRot1Y').value);
            let r1z = parseInt(document.getElementById('compRot1Z').value);

            // Get Frame 2 values
            let p2x = parseInt(document.getElementById('compPos2X').value);
            let p2y = parseInt(document.getElementById('compPos2Y').value);
            let p2z = parseInt(document.getElementById('compPos2Z').value);
            let r2x = parseInt(document.getElementById('compRot2X').value);
            let r2y = parseInt(document.getElementById('compRot2Y').value);
            let r2z = parseInt(document.getElementById('compRot2Z').value);

            // Update labels
            document.getElementById('comp1X').innerText = p1x;
            document.getElementById('comp1Y').innerText = p1y;
            document.getElementById('comp1Z').innerText = p1z;
            document.getElementById('comp1RX').innerText = r1x;
            document.getElementById('comp1RY').innerText = r1y;
            document.getElementById('comp1RZ').innerText = r1z;
            document.getElementById('comp2X').innerText = p2x;
            document.getElementById('comp2Y').innerText = p2y;
            document.getElementById('comp2Z').innerText = p2z;
            document.getElementById('comp2RX').innerText = r2x;
            document.getElementById('comp2RY').innerText = r2y;
            document.getElementById('comp2RZ').innerText = r2z;

            // Build transformation matrices
            let T1 = buildTransformMatrix(p1x, p1y, p1z, r1x, r1y, r1z);
            let T2 = buildTransformMatrix(p2x, p2y, p2z, r2x, r2y, r2z);

            // Compose: T3 = T1 * T2
            let T3 = multiplyMatrices(T1, T2);

            // Display result
            let html = formatMatrix(T3);
            document.getElementById('composedMatrix').innerHTML = html;
        }

        function buildTransformMatrix(px, py, pz, rx, ry, rz) {
            let radX = rx * (Math.PI / 180);
            let radY = ry * (Math.PI / 180);
            let radZ = rz * (Math.PI / 180);
            let cX = Math.cos(radX), sX = Math.sin(radX);
            let cY = Math.cos(radY), sY = Math.sin(radY);
            let cZ = Math.cos(radZ), sZ = Math.sin(radZ);

            // Rotation matrix Rz * Ry * Rx
            return [
                [cZ * cY, cZ * sY * sX - sZ * cX, cZ * sY * cX + sZ * sX, px],
                [sZ * cY, sZ * sY * sX + cZ * cX, sZ * sY * cX - cZ * sX, py],
                [-sY, cY * sX, cY * cX, pz],
                [0, 0, 0, 1]
            ];
        }

        function multiplyMatrices(A, B) {
            let result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    for (let k = 0; k < 4; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }

        function formatMatrix(M) {
            return `
                [ <span class="highlight-rot">${M[0][0].toFixed(3)}</span>, <span class="highlight-rot">${M[0][1].toFixed(3)}</span>, <span class="highlight-rot">${M[0][2].toFixed(3)}</span>, <span class="highlight-pos">${M[0][3].toFixed(1)}</span> ]<br>
                [ <span class="highlight-rot">${M[1][0].toFixed(3)}</span>, <span class="highlight-rot">${M[1][1].toFixed(3)}</span>, <span class="highlight-rot">${M[1][2].toFixed(3)}</span>, <span class="highlight-pos">${M[1][3].toFixed(1)}</span> ]<br>
                [ <span class="highlight-rot">${M[2][0].toFixed(3)}</span>, <span class="highlight-rot">${M[2][1].toFixed(3)}</span>, <span class="highlight-rot">${M[2][2].toFixed(3)}</span>, <span class="highlight-pos">${M[2][3].toFixed(1)}</span> ]<br>
                [ 0.000, 0.000, 0.000, 1.000 ]`;
        }

        // --- HOMOGENEOUS TRANSFORMATION SHOWCASE ---
        let transformMode = 'combined';
        function setTransformMode(mode) {
            transformMode = mode;
            updateShowcase();
        }

        function updateShowcase() {
            let px = parseInt(document.getElementById('posX').value);
            let py = parseInt(document.getElementById('posY').value);
            let pz = parseInt(document.getElementById('posZ').value);
            let rx = parseInt(document.getElementById('rotX').value);
            let ry = parseInt(document.getElementById('rotY').value);
            let rz = parseInt(document.getElementById('rotZ').value);

            let M;
            let info = '';

            if (transformMode === 'translation') {
                M = buildTransformMatrix(px, py, pz, 0, 0, 0);
                info = 'Translation only: R = I (identity), t = [' + px + ', ' + py + ', ' + pz + ']';
            } else if (transformMode === 'rotation') {
                M = buildTransformMatrix(0, 0, 0, rx, ry, rz);
                info = 'Rotation only: R = Rz(' + rz + '°) × Ry(' + ry + '°) × Rx(' + rx + '°), t = [0, 0, 0]';
            } else if (transformMode === 'identity') {
                M = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
                info = 'Identity matrix: no transformation applied';
            } else {
                M = buildTransformMatrix(px, py, pz, rx, ry, rz);
                info = 'Combined transformation: rotation and translation';
            }

            document.getElementById('showcaseMatrix').innerHTML = formatMatrix(M);
            document.getElementById('showcaseInfo').innerText = info;

            // Calculate properties
            let det = M[0][0] * (M[1][1] * M[2][2] - M[1][2] * M[2][1]) - M[0][1] * (M[1][0] * M[2][2] - M[1][2] * M[2][0]) + M[0][2] * (M[1][0] * M[2][1] - M[1][1] * M[2][0]);
            document.getElementById('detValue').innerText = det.toFixed(3);

            // Check orthogonality (R^T * R should be I)
            let R = [[M[0][0], M[0][1], M[0][2]], [M[1][0], M[1][1], M[1][2]], [M[2][0], M[2][1], M[2][2]]];
            let RT = [[R[0][0], R[1][0], R[2][0]], [R[0][1], R[1][1], R[2][1]], [R[0][2], R[1][2], R[2][2]]];
            let RTR = multiply3x3(RT, R);
            let isOrtho = Math.abs(RTR[0][0] - 1) < 0.1 && Math.abs(RTR[1][1] - 1) < 0.1 && Math.abs(RTR[2][2] - 1) < 0.1;
            document.getElementById('orthoValue').innerText = isOrtho ? 'Yes' : 'No';

            document.getElementById('transValue').innerText = '[' + M[0][3].toFixed(1) + ', ' + M[1][3].toFixed(1) + ', ' + M[2][3].toFixed(1) + ']';
            document.getElementById('rotTypeValue').innerText = 'Euler ZYX (Intrinsic)';
        }

        function multiply3x3(A, B) {
            let result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }

        // --- INVERSE TRANSFORMATION ---
        function updateInverse() {
            let px = parseInt(document.getElementById('posX').value);
            let py = parseInt(document.getElementById('posY').value);
            let pz = parseInt(document.getElementById('posZ').value);
            let rx = parseInt(document.getElementById('rotX').value);
            let ry = parseInt(document.getElementById('rotY').value);
            let rz = parseInt(document.getElementById('rotZ').value);

            let T = buildTransformMatrix(px, py, pz, rx, ry, rz);
            let T_inv = invertTransformMatrix(T);

            document.getElementById('invOriginalMatrix').innerHTML = formatMatrix(T);
            document.getElementById('invInverseMatrix').innerHTML = formatMatrix(T_inv);

            // Verify T * T^-1 = I
            let T_Tinv = multiplyMatrices(T, T_inv);
            let identity = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
            let isIdentity = true;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (Math.abs(T_Tinv[i][j] - identity[i][j]) > 0.01) isIdentity = false;
                }
            }

            let verifyHtml = formatMatrix(T_Tinv);
            verifyHtml += '<br><div style="margin-top:10px; color:' + (isIdentity ? '#0f0' : '#f00') + ';">';
            verifyHtml += isIdentity ? '✓ T × T⁻¹ = I (Identity)' : '✗ T × T⁻¹ ≠ I (Check calculation)';
            verifyHtml += '</div>';
            document.getElementById('invVerification').innerHTML = verifyHtml;
        }

        function invertTransformMatrix(T) {
            // Extract rotation and translation
            let R = [[T[0][0], T[0][1], T[0][2]], [T[1][0], T[1][1], T[1][2]], [T[2][0], T[2][1], T[2][2]]];
            let t = [T[0][3], T[1][3], T[2][3]];

            // R^T (transpose)
            let RT = [[R[0][0], R[1][0], R[2][0]], [R[0][1], R[1][1], R[2][1]], [R[0][2], R[1][2], R[2][2]]];

            // -R^T * t
            let negRTt = [
                -(RT[0][0] * t[0] + RT[0][1] * t[1] + RT[0][2] * t[2]),
                -(RT[1][0] * t[0] + RT[1][1] * t[1] + RT[1][2] * t[2]),
                -(RT[2][0] * t[0] + RT[2][1] * t[1] + RT[2][2] * t[2])
            ];

            return [
                [RT[0][0], RT[0][1], RT[0][2], negRTt[0]],
                [RT[1][0], RT[1][1], RT[1][2], negRTt[1]],
                [RT[2][0], RT[2][1], RT[2][2], negRTt[2]],
                [0, 0, 0, 1]
            ];
        }

        // Update showcase when main controls change
        let originalUpdateRobot = updateRobot;
        updateRobot = function () {
            originalUpdateRobot();
            updateShowcase();
            updateComposition();
        };

        // Initialize
        updateRobot();
        updateComposition();
        updateShowcase();
    </script>
</body>

</html>